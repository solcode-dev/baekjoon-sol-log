# 백준 17298번: 오큰수 - 오답노트

## 문제 정보
- **문제 번호**: 백준 17298번
- **문제명**: 오큰수
- **난이도**: Gold 4
- **사용 자료구조**: Stack, Vector

## 문제 요약
수열 A의 각 원소에 대해, 그 원소보다 오른쪽에 있으면서 더 큰 수 중 가장 왼쪽에 있는 수를 **오큰수(NGE)**라고 한다. 각 원소의 오큰수를 구하는 문제.

### 입출력 예시
```
입력:
4
3 5 2 7

출력:
5 7 7 -1
```

## 풀이 과정 및 최적화

### 1차 시도: 브루트포스 (O(n²))
**실행 결과**:
```
입력: [9, 5, 4, 8]
출력: -1 8 8 -1  // ❌ 잘못된 결과
```

**초기 코드**:
```cpp
for (int i = 0; i < a_size; i++) {
  for (int j = i + 1; j < a_size; j++) {
    if (a[i] < a[j]) {
      NEG[i] = a[j];
      break;
    }
  }
  if (NEG[i] == 0) {
    NEG[i] = -1;
  }
}
```

**문제점**:
1. 시간복잡도 O(n²) → N=1,000,000일 때 타임아웃
2. 로직 오류로 첫 번째 테스트 케이스에서 오답 발생

### 2차 시도: 스택 최적화 (O(n)) ✅
**실행 결과**:
```
입력: [3, 5, 2, 7]
출력: 5 7 7 -1  // ✅ 정답
```

**핵심 아이디어**: 
- 아직 오큰수를 찾지 못한 원소의 **인덱스**를 스택에 저장
- 현재 원소가 스택 top의 원소보다 크면 → 오큰수 발견!

**알고리즘 동작 과정**:
```
배열: [3, 5, 2, 7]

i=0: a[0]=3
  스택: [0]  (오큰수 미발견)

i=1: a[1]=5
  5 > a[0]=3 → NEG[0] = 5
  스택: [] → [1]

i=2: a[2]=2
  2 < a[1]=5 (오큰수 아님)
  스택: [1, 2]

i=3: a[3]=7
  7 > a[2]=2 → NEG[2] = 7
  7 > a[1]=5 → NEG[1] = 7
  스택: [] → [3]

종료: 스택에 남은 [3] → NEG[3] = -1
```

## 발견한 오류들

### 1. Vector 메서드 오류
```cpp
// ❌ 잘못된 방법
for (int i = 0; i < NEG.length(); i++)  // vector에는 length()가 없음!

// ✅ 올바른 방법
for (int i = 0; i < NEG.size(); i++)
```

**구분**:
- `vector`: `.size()` 사용
- `string`: `.size()` 또는 `.length()` 둘 다 사용 가능

### 2. 변수명 오타
```cpp
// ❌ 잘못된 코드
for (int i = 0; j < NEG.size(); i++)  // j 선언 안 됨, i와 불일치

// ✅ 올바른 코드
for (int i = 0; i < NEG.size(); i++)
```

## 최종 풀이 코드
```cpp
#include <iostream>
#include <stack>
#include <vector>
using namespace std;

int main() {
  int a_size;
  cin >> a_size;
  vector<int> a(a_size, 0);
  vector<int> NEG(a_size, 0);
  for (int k = 0; k < a_size; k++) {
    cin >> a[k];
  }

  // 1. 아직 오큰수를 찾지 못한 원소의 "인덱스"를 스택에 저장
  stack<int> s;
  s.push(0);

  // 2. 현재 원소가 스택 top의 원소보다 크면 오큰수
  for (int i = 1; i < a_size; i++) {
    while (!s.empty() && a[s.top()] < a[i]) {
      NEG[s.top()] = a[i];
      s.pop();
    }
    s.push(i);
  }

  // 3. 스택에 남은 인덱스는 오큰수가 없음
  while (!s.empty()) {
    NEG[s.top()] = -1;
    s.pop();
  }

  // 4. 출력
  for (int i = 0; i < NEG.size(); i++) {
    cout << NEG[i] << " ";
  }
}
```

## 핵심 체크포인트

### ✅ 스택 알고리즘 핵심
1. **스택에 저장**: 원소의 값이 아닌 **인덱스** 저장
2. **오큰수 조건**: `a[s.top()] < a[i]` → 현재 원소가 더 큼
3. **while문 사용**: 현재 원소보다 작은 모든 스택 원소 처리
4. **남은 인덱스**: 오큰수 없음 → `-1` 할당

### 🔑 시간복잡도 분석
- **브루트포스**: O(n²) → 최대 1조 번 연산 (타임아웃)
- **스택 사용**: O(n) → 각 원소는 스택에 최대 1번만 push/pop

## 배운 점
- 스택은 **아직 처리되지 않은 것**을 저장하는 데 유용
- **인덱스를 저장**하면 배열 접근과 결과 저장을 동시에 할 수 있음
- `vector`는 `.size()`, `string`은 `.size()` 또는 `.length()` 사용
- 반복문에서 변수명 오타 주의 (`i`와 `j` 혼동)
- O(n²) 알고리즘은 N이 클 때 스택/큐 등으로 최적화 필요
