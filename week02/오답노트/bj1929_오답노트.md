# 백준 1929번 - 소수 구하기 오답노트

## 📌 문제 정보
- **문제 번호**: 백준 1929번
- **문제명**: 소수 구하기
- **알고리즘**: 에라토스테네스의 체
- **난이도**: Silver III

---

## ❌ 발생한 오류

### 1. 런타임 오류 (Runtime Error)

**원인**: 정수 오버플로우

```cpp
// ❌ 문제가 있는 코드
for (int j = i * i; j <= n; j += i) {
    check[j] = true;
}
```

#### 왜 문제가 발생했나?

- `n`의 최대값: **1,000,000**
- `i`가 큰 값일 때 `i * i`는 `int` 범위를 초과할 수 있음
- 예: `i = 50,000`일 때 `i * i = 2,500,000,000`
- 오버플로우 발생 → 예상치 못한 동작 → 런타임 오류

#### ✅ 해결 방법

```cpp
for (int i = 2; i <= n; i++) {
    if (check[i] == false) {
        if ((long long)i * i > n) break;  // 오버플로우 방지
        for (int j = i * i; j <= n; j += i) {
            check[j] = true;
        }
    }
}
```

**핵심**: `i * i`를 계산하기 전에 `(long long)`으로 캐스팅하여 안전하게 비교

---

### 2. 틀렸습니다 (Wrong Answer)

**원인**: 1을 소수로 출력

```cpp
// ❌ 문제가 있는 코드
for (int i = m; i <= n; i++) {
    if (!check[i]) {
        cout << i << "\n";
    }
}
```

#### 왜 문제가 발생했나?

- `check` 배열은 2부터 체크하므로 `check[0]`과 `check[1]`은 항상 `false`
- `m = 1`일 때 1이 소수로 출력됨
- **하지만 1은 소수가 아님!**

#### ✅ 해결 방법

```cpp
for (int i = m; i <= n; i++) {
    if (i >= 2 && !check[i]) {  // i >= 2 조건 추가
        cout << i << "\n";
    }
}
```

**핵심**: 소수는 **2 이상의 자연수**이므로 `i >= 2` 조건 필수

---

## 💡 개념 정리

### 에라토스테네스의 체 (Sieve of Eratosthenes)

소수를 찾는 효율적인 알고리즘으로, 배수를 지워나가는 방식

#### 알고리즘 동작 과정

1. 2부터 n까지의 모든 수를 나열
2. 2는 소수이므로 2의 배수를 모두 제거 (4, 6, 8, 10, ...)
3. 3은 소수이므로 3의 배수를 모두 제거 (9, 12, 15, ...)
4. 5는 소수이므로 5의 배수를 모두 제거 (25, 30, 35, ...)
5. 반복...

#### 최적화 포인트

**Q. 왜 `i * i`부터 시작하나?**

- `i`의 배수 중 `i * i`보다 작은 수들은 이미 이전에 체크됨
- 예: `i = 5`일 때
  - `5 × 2 = 10`: 이미 2의 배수로 체크됨
  - `5 × 3 = 15`: 이미 3의 배수로 체크됨
  - `5 × 4 = 20`: 이미 2의 배수로 체크됨
  - `5 × 5 = 25`: **여기서부터 시작!**

**Q. 언제까지 반복하나?**

- `i * i > n`이면 더 이상 체크할 필요 없음
- 예: `n = 100`일 때 `i = 11`이면 `11 × 11 = 121 > 100`이므로 종료

#### 시간 복잡도

- **O(n log log n)**: 매우 효율적!
- 단순 반복문 O(n√n)보다 훨씬 빠름

---

## 🎯 핵심 포인트

### 1. 정수 오버플로우 주의

```cpp
// ❌ 위험: i * i가 int 범위를 초과할 수 있음
for (int j = i * i; j <= n; j += i)

// ✅ 안전: long long으로 캐스팅하여 비교
if ((long long)i * i > n) break;
```

### 2. 소수의 정의 확인

> **소수**: 1과 자기 자신으로만 나누어떨어지는 **2 이상의** 자연수

- 1은 소수가 아님!
- 출력 시 `i >= 2` 조건 필수

### 3. 에라토스테네스의 체 최적화

```cpp
// 최적화 1: i * i부터 시작
for (int j = i * i; j <= n; j += i)

// 최적화 2: i * i > n이면 종료
if ((long long)i * i > n) break;
```

### 4. vector 인덱스 타입

```cpp
vector<bool> check(n + 1);

// ❌ 에러: vector는 int 인덱스만 허용
for (long long j = i * i; j <= n; j += i) {
    check[j] = true;  // j가 long long이면 컴파일 에러
}

// ✅ 올바름: j는 int 타입 유지
for (int j = i * i; j <= n; j += i) {
    check[j] = true;
}
```

---

## 📝 최종 정답 코드

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
  int n, m;
  cin >> m;
  cin >> n;

  // 소수 체크
  vector<bool> check(n + 1, false); // 지워졌으면 true

  for (int i = 2; i <= n; i++) {
    if (check[i] == false) {
      if ((long long)i * i > n) break;  // 오버플로우 방지
      for (int j = i * i; j <= n; j += i) {
        check[j] = true;
      }
    }
  }

  for (int i = m; i <= n; i++) {
    if (i >= 2 && !check[i]) {  // 2 이상의 소수만 출력
      cout << i << "\n";
    }
  }
}
```

---

## 🔍 디버깅 체크리스트

- [ ] `i * i` 계산 시 오버플로우 체크했는가?
- [ ] 1을 소수로 출력하지 않도록 `i >= 2` 조건을 추가했는가?
- [ ] `vector` 인덱스는 `int` 타입을 사용하는가?
- [ ] `i * i > n`일 때 루프를 종료하는가?
- [ ] 입력 범위를 확인했는가? (1 ≤ m ≤ n ≤ 1,000,000)

---

## 💭 배운 점

1. **정수 오버플로우는 런타임 오류의 주요 원인**
   - 큰 수를 다룰 때는 항상 타입 범위를 확인
   - 필요시 `long long`으로 캐스팅

2. **수학적 정의를 정확히 이해하기**
   - 1은 소수가 아님을 명확히 인지
   - 엣지 케이스(m=1) 고려

3. **알고리즘 최적화의 중요성**
   - 에라토스테네스의 체는 `i * i`부터 시작하여 효율성 극대화
   - 불필요한 연산을 조기에 종료 (`break`)

4. **타입 호환성 주의**
   - `vector`의 인덱스는 `int` 타입만 허용
   - 타입 변환 시 컴파일 에러 발생 가능성 확인
