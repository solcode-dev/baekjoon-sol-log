# 백준 10799번: 쇠막대기 - 오답노트

## 문제 정보
- **문제 번호**: 백준 10799번
- **문제명**: 쇠막대기
- **난이도**: Silver 2
- **사용 자료구조**: Stack

## 문제 요약
여러 개의 쇠막대기가 겹쳐져 있고, 레이저로 잘랐을 때 생기는 쇠막대기 조각의 총 개수를 구하는 문제
- `()`: 레이저
- `( ... )`: 쇠막대기
- 레이저는 겹쳐진 모든 쇠막대기를 자름

### 입출력 예시
```
입력: ()(((()())(())()))(())
출력: 17
```

## 풀이 과정 및 발견한 오류

### 1차 시도: 잘못된 출력 (24 대신 17이 정답)
**실행 결과**: 
```
입력: ()(((()())(())()))(())
출력: 24  // ❌ 정답은 17
```

**원인**: 초기 코드에서 로직 오류 추정 (정확한 초기 코드는 실행 기록에 없지만, 출력값으로 유추)

### 2차 시도: 성공 ✅
**실행 결과**:
```
입력: ()(((()())(())()))(())
출력: 17  // ✅ 정답
```

**검증**:
```
입력: (((()(()()))(())()))(()())
출력: 24  // ✅ 정답
```

## 핵심 알고리즘

### 문자열 길이 구하기 이슈
```cpp
// ❌ 잘못된 방법 (C 스타일)
for (int i = 0; i < strlen(line); i++)

// ✅ 올바른 방법 (C++ string)
for (int i = 0; i < line.length(); i++)
```
- `strlen()`은 C 스타일 문자열(`char*`)용
- C++ `string` 객체는 `.length()` 또는 `.size()` 사용

### 레이저와 쇠막대기 구분
```cpp
if (line[i] == '(') {
  s.push(i);  // 인덱스를 스택에 저장
} else {  // ')'를 만났을 때
  if (i == s.top() + 1) {
    // 레이저: () 형태 (바로 직전이 '(')
    s.pop();
    ans += s.size();  // 현재 진행 중인 모든 쇠막대기가 잘림
  } else {
    // 쇠막대기 끝
    s.pop();
    ans += 1;  // 쇠막대기 하나가 끝남
  }
}
```

### 스택의 역할
- **저장 내용**: `(` 괄호의 **인덱스**
- **스택 크기**: 현재 진행 중인 쇠막대기 개수
- **레이저 판별**: `i == s.top() + 1` → 바로 직전 문자가 `(`였다는 의미

## 최종 풀이 코드
```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

int main() {
  string line;
  getline(cin, line);
  stack<int> s;  // 스택의 크기: 현재 진행 중인 쇠막대기 개수
  int ans = 0;

  for (int i = 0; i < line.length(); i++) {
    if (line[i] == '(') {
      s.push(i);
    } else {  // ')'를 만났을 때
      if (i == s.top() + 1) {  // 레이저
        s.pop();
        ans += s.size();
      } else {  // 쇠막대기 끝
        s.pop();
        ans += 1;
      }
    }
  }

  cout << ans;
}
```

## 핵심 체크포인트

### ✅ 반드시 이해해야 할 3가지
1. **레이저 판별**: `()`가 연속으로 나타나는 경우 → `i == s.top() + 1`로 확인
2. **스택 크기 활용**: 레이저를 만났을 때 스택 크기 = 잘리는 쇠막대기 개수
3. **쇠막대기 끝**: 레이저가 아닌 `)`는 쇠막대기 하나의 끝 → 조각 1개 추가

### 🔑 핵심 아이디어
- 스택에 인덱스를 저장함으로써 **바로 직전 문자**를 확인 가능
- 레이저는 모든 쇠막대기를 자르므로 → `스택 크기`만큼 조각 증가
- 쇠막대기 끝은 마지막 조각 1개 추가

## 배운 점
- C++ `string`에서는 `strlen()` 대신 `.length()` 사용
- 스택에 **값 자체**가 아닌 **인덱스**를 저장하여 추가 정보 활용 가능
- 레이저와 쇠막대기를 구분하는 핵심은 **연속된 괄호** 여부
